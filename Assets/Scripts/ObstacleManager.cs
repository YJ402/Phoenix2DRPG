using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

public class ObstacleManager : MonoBehaviour
{
    [Header("???? ???????")]
    public GameObject leftObj, rightObj;

    [Header("???? ??????")]
    public GameObject rock, spike, water, wall;

    [Header("???? ???? ????")]
    public bool dontOverlapAdj = true; //???? ????? ????? ????? ???
    public int AdjPadding = 1; //???? ????

    private int[,] grid; //???? ???? ???? ????. 
    //int cellValue = obstacleManager.GetGridValue(x, y);?? ???????? ????
    //cellValue?? 1??? ?????? ???, 2?? ?????? ??????? ????? ?????? ?? ???, 3??? ??????? ??? ???????

    private int minX, minY, maxX, maxY; //???? ????, ????
    private int gridWidth, gridHeight; //???? ?????? ????, ???? ????

    public struct GridObstacle
    {
        public int x, y; //????? ?????? x, y ???
        public int width, height; //?????? ????, ???? ???
    }

    public List<GridObstacle> obstacles = new(); //???? struct?? ?????? ????? ????

    public int[,] Grid => grid; //{get;} ??? ????? ???

    private void Start()
    {
        InitializeGrid(); //????? ????
        SpawnObstacle(rock, 1, 1, 3); //??, 1 x 1 ???, 3??
        SpawnObstacle(spike, 1, 1, 3); //????, 1 x 1 ???, 3??
        SpawnObstacle(water, 6, 2, 2); //??, 6 x 2 ???, 2??
        SpawnObstacle(wall, 5, 2, 2); //??, 5 x 2 ???, 2??
    }

    private void InitializeGrid()
    {
        Vector2 pos1 = leftObj.transform.position; //???? ????????? x, y ????????
        Vector2 pos2 = rightObj.transform.position; //?????? ????????? x, y ????????

        minX = Mathf.FloorToInt(Mathf.Min(pos1.x, pos2.x)); //????????? x ?? ??????? ?????? ???? ???? ???? ??????
        maxX = Mathf.CeilToInt(Mathf.Max(pos1.x, pos2.x)); //????????? x ?? ??????? ?????? ???? ? ???? ??????
        minY = Mathf.FloorToInt(Mathf.Min(pos1.y, pos2.y)); //????????? x ?? ??????? ?????? ???? ???? ???? ??????
        maxY = Mathf.CeilToInt(Mathf.Max(pos1.y, pos2.y)); //????????? x ?? ??????? ?????? ???? ? ???? ??????

        gridWidth = maxX - minX; //???x ?????? ???x ???? ?? ???
        gridHeight = maxY - minY; //???y ?????? ???y ???? ?? ???

        grid = new int[gridWidth, gridHeight]; //??????? ???? gridWidth, gridHeight ????? ??? ????
    }

    private void SpawnObstacle(GameObject prefab, int width, int height, int count) //??? ???????? (n * n ??????) n?? ????
    {
        const int maxAttempts = 100; //??? ??? ????? 100?
        int placedCount = 0; //???? ????? ?????? ?????? 0??
        int attempts = 0; //???? ??? ?? ????? 0?

        while (placedCount < count && attempts < maxAttempts) //????? ?????? count???? ???? attempt ????? ??????
        {
            //Random.Range(0, 2)?? ???? ??? 0 ~ 1????? ?????? ???? +1?? ?????? ??
            int gridX = Random.Range(0, gridWidth - width + 1); //gridX?? 0???? (????? ???? - ??????? ???? + 1)?? ??. 
            int gridY = Random.Range(0, gridHeight - height + 1); //gridY?? 0???? (????? ???? - ??????? ???? + 1)?? ??. 

            if (AreaAvailable(gridX, gridY, width, height))
            {
                MarkArea(gridX, gridY, width, height, prefab);

                Vector2 worldPos = GridToWorld(gridX + width / 2.0f, gridY + height / 2.0f);
                //?????? 3, 4?? ??????? ??? 2, 2??? ??????? (3+2)/2, (4+2)/2?? 4, 5?? ??. 
                //GridToWorld?? ????? ????? ???? ?????? ????? ???
                Instantiate(prefab, worldPos, Quaternion.identity, transform);

                GridObstacle obstacle = new GridObstacle
                //gridX, gridY, width, height?? ???? ???? struct?? x, y, width, height?? ???
                {
                    x = gridX,
                    y = gridY,
                    width = width,
                    height = height,
                };
                obstacles.Add(obstacle); //??? ?????? obstacles??? ??????? ???
                Debug.Log($"{obstacle.x}, {obstacle.y} ????? ???? ??????");

                placedCount++; //????? ???? ???? 1 ????
            }
            attempts++; //??? ??? ????
        }
    }
    private bool AreaAvailable(int objPosX, int objPosY, int width, int height)
    {
        if (objPosX < 0 || objPosX + width > gridWidth || objPosY < 0 || objPosY + height > gridHeight) return false;
        //????? ?????? ?????? ??? false?? ?????
        if (dontOverlapAdj) //????? ????? ???
        {
            int checkObjPosX = Mathf.Max(0, objPosX - AdjPadding);
            int checkObjPosY = Mathf.Max(0, objPosY - AdjPadding);
            int checkEndX = Mathf.Min(gridWidth, objPosX + width + AdjPadding);
            int checkEndY = Mathf.Min(gridHeight, objPosY + height + AdjPadding);
            //????????? ?? ?¥ê? ???. gridWidth???? objPosX?? ??? ?????? ??????. 
            //???¡À? gridHeight?? 10, objPosY?? 4, height?? 2, adjPadding?? 1???? 4???? 7???? ?????. 

            for (int x = checkObjPosX; x < checkEndX; x++)
            {
                for (int y = checkObjPosY; y < checkEndY; y++)
                {
                    if (grid[x, y] != 0) //x, y?? 0?? ??? ??? ??, ???? ??? ??? ?????
                    {
                        return false; //?????? ???? ??? ????? ????
                    }
                }
            }
        }
        else
        {
            for (int x = objPosX; x < objPosX + width; x++)
            {
                for (int y = objPosY; y < objPosY + height; y++)
                {
                    if (grid[x, y] != 0) //x, y?? 0?? ??? ??? ??, ???? ??? ??? ?????
                    {
                        return false;  //?????? ???? ??? ????? ????
                    }
                }
            }
        }
        return true; //????? ??? true?? ?????? ?????? ????? ?? ??? ????
    }

    private void MarkArea(int objPosX, int objPosY, int width, int height, GameObject prefab) //?????? x, y ??? ?? ???? ???
    {
        int obstacleValue = (prefab == water) ? 3 : 1; //???????? ???? ??? obstacleValue?? 1?? ??? 3???? ??????

        for (int x = objPosX; x < objPosX + width; x++) //x?? ?????? x???, x??? + ??????? ?????? ??? ???
        {
            for (int y = objPosY; y < objPosY + height; y++) //y?? ?????? y???, y??? + ??????? ?????? ??? ???
            {
                grid[x, y] = obstacleValue; //?????? ????? ?????? 1?? ????
            }
        }

        if (dontOverlapAdj)
        {
            for (int x = objPosX - AdjPadding; x < objPosX + width + AdjPadding; x++)
            {
                for (int y = objPosY - AdjPadding; y < objPosY + height + AdjPadding; y++)
                {
                    // ???? ??????? ?¥í??? ??? ????? ??? ????? ???
                    if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight)
                    {
                        // ???? ????? ?????
                        bool isInsideObstacle = (x >= objPosX && x < objPosX + width &&
                                               y >= objPosY && y < objPosY + height);

                        if (!isInsideObstacle && grid[x, y] == 0)
                        {
                            grid[x, y] = 2; // ???? ?????? 2?? ??????
                        }
                    }
                }
            }
        }
    }
    private Vector2 GridToWorld(float gridX, float gridY)
    {
        return new Vector2(minX + gridX, minY + gridY);
        //minX??? ??? x???? gridX????? ????? ???? ???
    }

    public Vector2Int WorldToGrid(Vector2 worldPos) //worldPos?? ?????? ???
    {
        int x = Mathf.FloorToInt(worldPos.x - minX); //????? ????? ???????
        int y = Mathf.FloorToInt(worldPos.y - minY);
        return new Vector2Int(x, y);
    }

    // ????? ???? ??? (0: ?? ????, 1: ????, 2: ???? ????, 3: ??, -1: ??????? ???? ???)
    public int GetGridValue(int x, int y)
    {
        if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight)
        {
            return grid[x, y]; //x?? y?? ????? ???? ???? ???? ??????? ?????
        }
        return -1; //??? ??? -1?? ???
    }
}